# -*- coding: utf-8 -*-
"""4th A*pathFinder.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16mwmfS5eX_OhtWfIzj63NEXY6bNQNkpz
"""

import heapq

# Define a class to represent each node in the graph
class Node:
    def __init__(self, row, col):
        self.row = row
        self.col = col
        self.g_cost = float('inf')  # Cost from start node to current node (initialized as infinity)
        self.h_cost = 0  # Heuristic cost from current node to destination node
        self.f_cost = 0  # Total estimated cost (f_cost = g_cost + h_cost)
        self.parent = None  # Parent node for path reconstruction

    def __lt__(self, other):
        return self.f_cost < other.f_cost

# A helper function to calculate the heuristic cost (Euclidean distance)
def calculate_heuristic(current_node, goal_node):
    return ((current_node.row - goal_node.row) ** 2 + (current_node.col - goal_node.col) ** 2) ** 0.5

# A* algorithm implementation
def astar(grid, start, goal):
    rows = len(grid)
    cols = len(grid[0])
    open_list = []
    closed_list = []

    # Initialize the start and goal nodes
    start_node = Node(start[0], start[1])
    goal_node = Node(goal[0], goal[1])
    start_node.g_cost = 0
    start_node.h_cost = calculate_heuristic(start_node, goal_node)
    start_node.f_cost = start_node.g_cost + start_node.h_cost
    heapq.heappush(open_list, start_node)

    # Check if a node is valid and not blocked
    def is_valid_node(row, col):
        return 0 <= row < rows and 0 <= col < cols and grid[row][col] != 1

    # Get the neighboring nodes of a given node
    def get_neighbors(current_node):
        neighbors = []
        deltas = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, down, left, right
        for delta in deltas:
            neighbor_row = current_node.row + delta[0]
            neighbor_col = current_node.col + delta[1]
            if is_valid_node(neighbor_row, neighbor_col):
                neighbor = Node(neighbor_row, neighbor_col)
                neighbors.append(neighbor)
        return neighbors

    while open_list:
        # Get the node with the lowest f_cost from the open list
        current_node = heapq.heappop(open_list)

        # Check if the current node is the goal node
        if current_node.row == goal_node.row and current_node.col == goal_node.col:
            path = []
            while current_node:
                path.append((current_node.row, current_node.col))
                current_node = current_node.parent
            path.reverse()
            return path

        closed_list.append(current_node)

        # Explore the neighbors of the current node
        for neighbor in get_neighbors(current_node):
            # Skip neighbors in the closed list
            if neighbor in closed_list:
                continue

            # Calculate the cost from the start node to the neighbor
            tentative_g_cost = current_node.g_cost + 1  # Assuming each step has a cost of 1

            # Update the neighbor if it is not in the open list or has a lower cost
            if tentative_g_cost < neighbor.g_cost:
                neighbor.g_cost = tentative_g_cost
                neighbor.h_cost = calculate_heuristic(neighbor, goal_node)
                neighbor.f_cost = neighbor.g_cost + neighbor.h_cost
                neighbor.parent = current_node

                # Add the neighbor to the open list if it is not already there
                if neighbor not in open_list:
                    heapq.heappush(open_list, neighbor)

    # If the open list is empty and the goal node has not been reached, there is no path
    return None

# Example usage
grid = [
    [0, 0, 0, 0],
    [0, 1, 0, 1],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
]
start = (0, 0)
goal = (3, 3)
path = astar(grid, start, goal)
if path:
    print("Path found:", path)
else:
    print("No path found.")